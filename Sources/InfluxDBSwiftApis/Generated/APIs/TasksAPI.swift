//
// TasksAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import InfluxDBSwift

extension InfluxDB2API {


public struct TasksAPI {
    private let influxDB2API: InfluxDB2API

    public init(influxDB2API: InfluxDB2API) {
        self.influxDB2API = influxDB2API
    }

    /**
     Delete a task
     
     - parameter taskID: (path) The ID of the task to delete. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func deleteTasksID(taskID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: Void?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        deleteTasksIDWithRequestBuilder(taskID: taskID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     Delete a task
     
     - parameter taskID: (path) The ID of the task to delete. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func deleteTasksID(taskID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> Void? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void?, Error>) -> Void in
            deleteTasksIDWithRequestBuilder(taskID: taskID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    continuation.resume(returning: ())
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     Delete a task
     - DELETE /tasks/{taskID}
     - Deletes a task and all associated records
     - parameter taskID: (path) The ID of the task to delete. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<Void> 
     */
    internal func deleteTasksIDWithRequestBuilder(taskID: String, zapTraceSpan: String? = nil) -> RequestBuilder<Void> {
        var path = "/tasks/{taskID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void> = influxDB2API.requestBuilderFactory.getRequestNonDecodableBuilder(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     Delete a label from a task
     
     - parameter taskID: (path) The task ID. 
     - parameter labelID: (path) The label ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func deleteTasksIDLabelsID(taskID: String, labelID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: Void?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        deleteTasksIDLabelsIDWithRequestBuilder(taskID: taskID, labelID: labelID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     Delete a label from a task
     
     - parameter taskID: (path) The task ID. 
     - parameter labelID: (path) The label ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func deleteTasksIDLabelsID(taskID: String, labelID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> Void? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void?, Error>) -> Void in
            deleteTasksIDLabelsIDWithRequestBuilder(taskID: taskID, labelID: labelID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    continuation.resume(returning: ())
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     Delete a label from a task
     - DELETE /tasks/{taskID}/labels/{labelID}
     - parameter taskID: (path) The task ID. 
     - parameter labelID: (path) The label ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<Void> 
     */
    internal func deleteTasksIDLabelsIDWithRequestBuilder(taskID: String, labelID: String, zapTraceSpan: String? = nil) -> RequestBuilder<Void> {
        var path = "/tasks/{taskID}/labels/{labelID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let labelIDPreEscape = "\(APIHelper.mapValueToPathItem(labelID))"
        let labelIDPostEscape = labelIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{labelID}", with: labelIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void> = influxDB2API.requestBuilderFactory.getRequestNonDecodableBuilder(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     Remove a member from a task
     
     - parameter userID: (path) The ID of the member to remove. 
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func deleteTasksIDMembersID(userID: String, taskID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: Void?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        deleteTasksIDMembersIDWithRequestBuilder(userID: userID, taskID: taskID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     Remove a member from a task
     
     - parameter userID: (path) The ID of the member to remove. 
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func deleteTasksIDMembersID(userID: String, taskID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> Void? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void?, Error>) -> Void in
            deleteTasksIDMembersIDWithRequestBuilder(userID: userID, taskID: taskID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    continuation.resume(returning: ())
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     Remove a member from a task
     - DELETE /tasks/{taskID}/members/{userID}
     - parameter userID: (path) The ID of the member to remove. 
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<Void> 
     */
    internal func deleteTasksIDMembersIDWithRequestBuilder(userID: String, taskID: String, zapTraceSpan: String? = nil) -> RequestBuilder<Void> {
        var path = "/tasks/{taskID}/members/{userID}"
        let userIDPreEscape = "\(APIHelper.mapValueToPathItem(userID))"
        let userIDPostEscape = userIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userID}", with: userIDPostEscape, options: .literal, range: nil)
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void> = influxDB2API.requestBuilderFactory.getRequestNonDecodableBuilder(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     Remove an owner from a task
     
     - parameter userID: (path) The ID of the owner to remove. 
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func deleteTasksIDOwnersID(userID: String, taskID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: Void?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        deleteTasksIDOwnersIDWithRequestBuilder(userID: userID, taskID: taskID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     Remove an owner from a task
     
     - parameter userID: (path) The ID of the owner to remove. 
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func deleteTasksIDOwnersID(userID: String, taskID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> Void? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void?, Error>) -> Void in
            deleteTasksIDOwnersIDWithRequestBuilder(userID: userID, taskID: taskID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    continuation.resume(returning: ())
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     Remove an owner from a task
     - DELETE /tasks/{taskID}/owners/{userID}
     - parameter userID: (path) The ID of the owner to remove. 
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<Void> 
     */
    internal func deleteTasksIDOwnersIDWithRequestBuilder(userID: String, taskID: String, zapTraceSpan: String? = nil) -> RequestBuilder<Void> {
        var path = "/tasks/{taskID}/owners/{userID}"
        let userIDPreEscape = "\(APIHelper.mapValueToPathItem(userID))"
        let userIDPostEscape = userIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userID}", with: userIDPostEscape, options: .literal, range: nil)
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void> = influxDB2API.requestBuilderFactory.getRequestNonDecodableBuilder(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     Cancel a running task
     
     - parameter taskID: (path) The task ID. 
     - parameter runID: (path) The run ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func deleteTasksIDRunsID(taskID: String, runID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: Void?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        deleteTasksIDRunsIDWithRequestBuilder(taskID: taskID, runID: runID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     Cancel a running task
     
     - parameter taskID: (path) The task ID. 
     - parameter runID: (path) The run ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func deleteTasksIDRunsID(taskID: String, runID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> Void? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void?, Error>) -> Void in
            deleteTasksIDRunsIDWithRequestBuilder(taskID: taskID, runID: runID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    continuation.resume(returning: ())
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     Cancel a running task
     - DELETE /tasks/{taskID}/runs/{runID}
     - parameter taskID: (path) The task ID. 
     - parameter runID: (path) The run ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<Void> 
     */
    internal func deleteTasksIDRunsIDWithRequestBuilder(taskID: String, runID: String, zapTraceSpan: String? = nil) -> RequestBuilder<Void> {
        var path = "/tasks/{taskID}/runs/{runID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let runIDPreEscape = "\(APIHelper.mapValueToPathItem(runID))"
        let runIDPostEscape = runIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{runID}", with: runIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void> = influxDB2API.requestBuilderFactory.getRequestNonDecodableBuilder(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     * enum for parameter status
     */
    public enum Status_getTasks: String, CaseIterable {
        case active = "active"
        case inactive = "inactive"
    }

    /**
     * enum for parameter type
     */
    public enum ModelType_getTasks: String, CaseIterable {
        case basic = "basic"
        case system = "system"
    }

    /**
     List all tasks
     
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter name: (query) Returns task with a specific name. (optional)
     - parameter after: (query) Return tasks after a specified ID. (optional)
     - parameter user: (query) Filter tasks to a specific user ID. (optional)
     - parameter org: (query) Filter tasks to a specific organization name. (optional)
     - parameter orgID: (query) Filter tasks to a specific organization ID. (optional)
     - parameter status: (query) Filter tasks by a status--\&quot;inactive\&quot; or \&quot;active\&quot;. (optional)
     - parameter limit: (query) The number of tasks to return (optional, default to 100)
     - parameter type: (query) Type of task, unset by default. (optional, default to .empty)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func getTasks(zapTraceSpan: String? = nil, name: String? = nil, after: String? = nil, user: String? = nil, org: String? = nil, orgID: String? = nil, status: Status_getTasks? = nil, limit: Int? = nil, type: ModelType_getTasks? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: Tasks?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        getTasksWithRequestBuilder(zapTraceSpan: zapTraceSpan, name: name, after: after, user: user, org: org, orgID: orgID, status: status, limit: limit, type: type).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     List all tasks
     
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter name: (query) Returns task with a specific name. (optional)
     - parameter after: (query) Return tasks after a specified ID. (optional)
     - parameter user: (query) Filter tasks to a specific user ID. (optional)
     - parameter org: (query) Filter tasks to a specific organization name. (optional)
     - parameter orgID: (query) Filter tasks to a specific organization ID. (optional)
     - parameter status: (query) Filter tasks by a status--\&quot;inactive\&quot; or \&quot;active\&quot;. (optional)
     - parameter limit: (query) The number of tasks to return (optional, default to 100)
     - parameter type: (query) Type of task, unset by default. (optional, default to .empty)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func getTasks(zapTraceSpan: String? = nil, name: String? = nil, after: String? = nil, user: String? = nil, org: String? = nil, orgID: String? = nil, status: Status_getTasks? = nil, limit: Int? = nil, type: ModelType_getTasks? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> Tasks? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Tasks?, Error>) -> Void in
            getTasksWithRequestBuilder(zapTraceSpan: zapTraceSpan, name: name, after: after, user: user, org: org, orgID: orgID, status: status, limit: limit, type: type).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     List all tasks
     - GET /tasks
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter name: (query) Returns task with a specific name. (optional)
     - parameter after: (query) Return tasks after a specified ID. (optional)
     - parameter user: (query) Filter tasks to a specific user ID. (optional)
     - parameter org: (query) Filter tasks to a specific organization name. (optional)
     - parameter orgID: (query) Filter tasks to a specific organization ID. (optional)
     - parameter status: (query) Filter tasks by a status--\&quot;inactive\&quot; or \&quot;active\&quot;. (optional)
     - parameter limit: (query) The number of tasks to return (optional, default to 100)
     - parameter type: (query) Type of task, unset by default. (optional, default to .empty)
     - returns: RequestBuilder<Tasks> 
     */
    internal func getTasksWithRequestBuilder(zapTraceSpan: String? = nil, name: String? = nil, after: String? = nil, user: String? = nil, org: String? = nil, orgID: String? = nil, status: Status_getTasks? = nil, limit: Int? = nil, type: ModelType_getTasks? = nil) -> RequestBuilder<Tasks> {
        let path = "/tasks"
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "name": name?.encodeToJSON(), 
            "after": after?.encodeToJSON(), 
            "user": user?.encodeToJSON(), 
            "org": org?.encodeToJSON(), 
            "orgID": orgID?.encodeToJSON(), 
            "status": status?.encodeToJSON(), 
            "limit": limit?.encodeToJSON(), 
            "type": type?.encodeToJSON()
        ])
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Tasks> = influxDB2API.requestBuilderFactory.getRequestDecodableBuilder(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     Retrieve a task
     
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func getTasksID(taskID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: Task?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        getTasksIDWithRequestBuilder(taskID: taskID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     Retrieve a task
     
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func getTasksID(taskID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> Task? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Task?, Error>) -> Void in
            getTasksIDWithRequestBuilder(taskID: taskID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     Retrieve a task
     - GET /tasks/{taskID}
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<Task> 
     */
    internal func getTasksIDWithRequestBuilder(taskID: String, zapTraceSpan: String? = nil) -> RequestBuilder<Task> {
        var path = "/tasks/{taskID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Task> = influxDB2API.requestBuilderFactory.getRequestDecodableBuilder(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     List all labels for a task
     
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func getTasksIDLabels(taskID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: LabelsResponse?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        getTasksIDLabelsWithRequestBuilder(taskID: taskID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     List all labels for a task
     
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func getTasksIDLabels(taskID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> LabelsResponse? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<LabelsResponse?, Error>) -> Void in
            getTasksIDLabelsWithRequestBuilder(taskID: taskID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     List all labels for a task
     - GET /tasks/{taskID}/labels
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<LabelsResponse> 
     */
    internal func getTasksIDLabelsWithRequestBuilder(taskID: String, zapTraceSpan: String? = nil) -> RequestBuilder<LabelsResponse> {
        var path = "/tasks/{taskID}/labels"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<LabelsResponse> = influxDB2API.requestBuilderFactory.getRequestDecodableBuilder(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     Retrieve all logs for a task
     
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func getTasksIDLogs(taskID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: Logs?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        getTasksIDLogsWithRequestBuilder(taskID: taskID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     Retrieve all logs for a task
     
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func getTasksIDLogs(taskID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> Logs? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Logs?, Error>) -> Void in
            getTasksIDLogsWithRequestBuilder(taskID: taskID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     Retrieve all logs for a task
     - GET /tasks/{taskID}/logs
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<Logs> 
     */
    internal func getTasksIDLogsWithRequestBuilder(taskID: String, zapTraceSpan: String? = nil) -> RequestBuilder<Logs> {
        var path = "/tasks/{taskID}/logs"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Logs> = influxDB2API.requestBuilderFactory.getRequestDecodableBuilder(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     List all task members
     
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func getTasksIDMembers(taskID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: ResourceMembers?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        getTasksIDMembersWithRequestBuilder(taskID: taskID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     List all task members
     
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func getTasksIDMembers(taskID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> ResourceMembers? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<ResourceMembers?, Error>) -> Void in
            getTasksIDMembersWithRequestBuilder(taskID: taskID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     List all task members
     - GET /tasks/{taskID}/members
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<ResourceMembers> 
     */
    internal func getTasksIDMembersWithRequestBuilder(taskID: String, zapTraceSpan: String? = nil) -> RequestBuilder<ResourceMembers> {
        var path = "/tasks/{taskID}/members"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<ResourceMembers> = influxDB2API.requestBuilderFactory.getRequestDecodableBuilder(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     List all owners of a task
     
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func getTasksIDOwners(taskID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: ResourceOwners?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        getTasksIDOwnersWithRequestBuilder(taskID: taskID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     List all owners of a task
     
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func getTasksIDOwners(taskID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> ResourceOwners? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<ResourceOwners?, Error>) -> Void in
            getTasksIDOwnersWithRequestBuilder(taskID: taskID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     List all owners of a task
     - GET /tasks/{taskID}/owners
     - parameter taskID: (path) The task ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<ResourceOwners> 
     */
    internal func getTasksIDOwnersWithRequestBuilder(taskID: String, zapTraceSpan: String? = nil) -> RequestBuilder<ResourceOwners> {
        var path = "/tasks/{taskID}/owners"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<ResourceOwners> = influxDB2API.requestBuilderFactory.getRequestDecodableBuilder(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     List runs for a task
     
     - parameter taskID: (path) The ID of the task to get runs for. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter after: (query) Returns runs after a specific ID. (optional)
     - parameter limit: (query) The number of runs to return (optional, default to 100)
     - parameter afterTime: (query) Filter runs to those scheduled after this time, RFC3339 (optional)
     - parameter beforeTime: (query) Filter runs to those scheduled before this time, RFC3339 (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func getTasksIDRuns(taskID: String, zapTraceSpan: String? = nil, after: String? = nil, limit: Int? = nil, afterTime: Date? = nil, beforeTime: Date? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: Runs?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        getTasksIDRunsWithRequestBuilder(taskID: taskID, zapTraceSpan: zapTraceSpan, after: after, limit: limit, afterTime: afterTime, beforeTime: beforeTime).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     List runs for a task
     
     - parameter taskID: (path) The ID of the task to get runs for. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter after: (query) Returns runs after a specific ID. (optional)
     - parameter limit: (query) The number of runs to return (optional, default to 100)
     - parameter afterTime: (query) Filter runs to those scheduled after this time, RFC3339 (optional)
     - parameter beforeTime: (query) Filter runs to those scheduled before this time, RFC3339 (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func getTasksIDRuns(taskID: String, zapTraceSpan: String? = nil, after: String? = nil, limit: Int? = nil, afterTime: Date? = nil, beforeTime: Date? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> Runs? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Runs?, Error>) -> Void in
            getTasksIDRunsWithRequestBuilder(taskID: taskID, zapTraceSpan: zapTraceSpan, after: after, limit: limit, afterTime: afterTime, beforeTime: beforeTime).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     List runs for a task
     - GET /tasks/{taskID}/runs
     - parameter taskID: (path) The ID of the task to get runs for. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter after: (query) Returns runs after a specific ID. (optional)
     - parameter limit: (query) The number of runs to return (optional, default to 100)
     - parameter afterTime: (query) Filter runs to those scheduled after this time, RFC3339 (optional)
     - parameter beforeTime: (query) Filter runs to those scheduled before this time, RFC3339 (optional)
     - returns: RequestBuilder<Runs> 
     */
    internal func getTasksIDRunsWithRequestBuilder(taskID: String, zapTraceSpan: String? = nil, after: String? = nil, limit: Int? = nil, afterTime: Date? = nil, beforeTime: Date? = nil) -> RequestBuilder<Runs> {
        var path = "/tasks/{taskID}/runs"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "after": after?.encodeToJSON(), 
            "limit": limit?.encodeToJSON(), 
            "afterTime": afterTime?.encodeToJSON(), 
            "beforeTime": beforeTime?.encodeToJSON()
        ])
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Runs> = influxDB2API.requestBuilderFactory.getRequestDecodableBuilder(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     Retrieve a single run for a task
     
     - parameter taskID: (path) The task ID. 
     - parameter runID: (path) The run ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func getTasksIDRunsID(taskID: String, runID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: Run?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        getTasksIDRunsIDWithRequestBuilder(taskID: taskID, runID: runID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     Retrieve a single run for a task
     
     - parameter taskID: (path) The task ID. 
     - parameter runID: (path) The run ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func getTasksIDRunsID(taskID: String, runID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> Run? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Run?, Error>) -> Void in
            getTasksIDRunsIDWithRequestBuilder(taskID: taskID, runID: runID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     Retrieve a single run for a task
     - GET /tasks/{taskID}/runs/{runID}
     - parameter taskID: (path) The task ID. 
     - parameter runID: (path) The run ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<Run> 
     */
    internal func getTasksIDRunsIDWithRequestBuilder(taskID: String, runID: String, zapTraceSpan: String? = nil) -> RequestBuilder<Run> {
        var path = "/tasks/{taskID}/runs/{runID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let runIDPreEscape = "\(APIHelper.mapValueToPathItem(runID))"
        let runIDPostEscape = runIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{runID}", with: runIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Run> = influxDB2API.requestBuilderFactory.getRequestDecodableBuilder(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     Retrieve all logs for a run
     
     - parameter taskID: (path) ID of task to get logs for. 
     - parameter runID: (path) ID of run to get logs for. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func getTasksIDRunsIDLogs(taskID: String, runID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: Logs?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        getTasksIDRunsIDLogsWithRequestBuilder(taskID: taskID, runID: runID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     Retrieve all logs for a run
     
     - parameter taskID: (path) ID of task to get logs for. 
     - parameter runID: (path) ID of run to get logs for. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func getTasksIDRunsIDLogs(taskID: String, runID: String, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> Logs? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Logs?, Error>) -> Void in
            getTasksIDRunsIDLogsWithRequestBuilder(taskID: taskID, runID: runID, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     Retrieve all logs for a run
     - GET /tasks/{taskID}/runs/{runID}/logs
     - parameter taskID: (path) ID of task to get logs for. 
     - parameter runID: (path) ID of run to get logs for. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<Logs> 
     */
    internal func getTasksIDRunsIDLogsWithRequestBuilder(taskID: String, runID: String, zapTraceSpan: String? = nil) -> RequestBuilder<Logs> {
        var path = "/tasks/{taskID}/runs/{runID}/logs"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let runIDPreEscape = "\(APIHelper.mapValueToPathItem(runID))"
        let runIDPostEscape = runIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{runID}", with: runIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Logs> = influxDB2API.requestBuilderFactory.getRequestDecodableBuilder(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     Update a task
     
     - parameter taskID: (path) The task ID. 
     - parameter taskUpdateRequest: (body) Task update to apply 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func patchTasksID(taskID: String, taskUpdateRequest: TaskUpdateRequest, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: Task?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        patchTasksIDWithRequestBuilder(taskID: taskID, taskUpdateRequest: taskUpdateRequest, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     Update a task
     
     - parameter taskID: (path) The task ID. 
     - parameter taskUpdateRequest: (body) Task update to apply 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func patchTasksID(taskID: String, taskUpdateRequest: TaskUpdateRequest, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> Task? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Task?, Error>) -> Void in
            patchTasksIDWithRequestBuilder(taskID: taskID, taskUpdateRequest: taskUpdateRequest, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     Update a task
     - PATCH /tasks/{taskID}
     - Update a task. This will cancel all queued runs.
     - parameter taskID: (path) The task ID. 
     - parameter taskUpdateRequest: (body) Task update to apply 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<Task> 
     */
    internal func patchTasksIDWithRequestBuilder(taskID: String, taskUpdateRequest: TaskUpdateRequest, zapTraceSpan: String? = nil) -> RequestBuilder<Task> {
        var path = "/tasks/{taskID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: taskUpdateRequest)

        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Task> = influxDB2API.requestBuilderFactory.getRequestDecodableBuilder(method: "PATCH", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     Create a new task
     
     - parameter taskCreateRequest: (body) Task to create 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func postTasks(taskCreateRequest: TaskCreateRequest, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: Task?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        postTasksWithRequestBuilder(taskCreateRequest: taskCreateRequest, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     Create a new task
     
     - parameter taskCreateRequest: (body) Task to create 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func postTasks(taskCreateRequest: TaskCreateRequest, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> Task? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Task?, Error>) -> Void in
            postTasksWithRequestBuilder(taskCreateRequest: taskCreateRequest, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     Create a new task
     - POST /tasks
     - parameter taskCreateRequest: (body) Task to create 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<Task> 
     */
    internal func postTasksWithRequestBuilder(taskCreateRequest: TaskCreateRequest, zapTraceSpan: String? = nil) -> RequestBuilder<Task> {
        let path = "/tasks"
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: taskCreateRequest)

        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Task> = influxDB2API.requestBuilderFactory.getRequestDecodableBuilder(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     Add a label to a task
     
     - parameter taskID: (path) The task ID. 
     - parameter labelMapping: (body) Label to add 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func postTasksIDLabels(taskID: String, labelMapping: LabelMapping, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: LabelResponse?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        postTasksIDLabelsWithRequestBuilder(taskID: taskID, labelMapping: labelMapping, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     Add a label to a task
     
     - parameter taskID: (path) The task ID. 
     - parameter labelMapping: (body) Label to add 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func postTasksIDLabels(taskID: String, labelMapping: LabelMapping, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> LabelResponse? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<LabelResponse?, Error>) -> Void in
            postTasksIDLabelsWithRequestBuilder(taskID: taskID, labelMapping: labelMapping, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     Add a label to a task
     - POST /tasks/{taskID}/labels
     - parameter taskID: (path) The task ID. 
     - parameter labelMapping: (body) Label to add 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<LabelResponse> 
     */
    internal func postTasksIDLabelsWithRequestBuilder(taskID: String, labelMapping: LabelMapping, zapTraceSpan: String? = nil) -> RequestBuilder<LabelResponse> {
        var path = "/tasks/{taskID}/labels"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: labelMapping)

        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<LabelResponse> = influxDB2API.requestBuilderFactory.getRequestDecodableBuilder(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     Add a member to a task
     
     - parameter taskID: (path) The task ID. 
     - parameter addResourceMemberRequestBody: (body) User to add as member 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func postTasksIDMembers(taskID: String, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: ResourceMember?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        postTasksIDMembersWithRequestBuilder(taskID: taskID, addResourceMemberRequestBody: addResourceMemberRequestBody, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     Add a member to a task
     
     - parameter taskID: (path) The task ID. 
     - parameter addResourceMemberRequestBody: (body) User to add as member 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func postTasksIDMembers(taskID: String, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> ResourceMember? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<ResourceMember?, Error>) -> Void in
            postTasksIDMembersWithRequestBuilder(taskID: taskID, addResourceMemberRequestBody: addResourceMemberRequestBody, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     Add a member to a task
     - POST /tasks/{taskID}/members
     - parameter taskID: (path) The task ID. 
     - parameter addResourceMemberRequestBody: (body) User to add as member 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<ResourceMember> 
     */
    internal func postTasksIDMembersWithRequestBuilder(taskID: String, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan: String? = nil) -> RequestBuilder<ResourceMember> {
        var path = "/tasks/{taskID}/members"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: addResourceMemberRequestBody)

        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<ResourceMember> = influxDB2API.requestBuilderFactory.getRequestDecodableBuilder(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     Add an owner to a task
     
     - parameter taskID: (path) The task ID. 
     - parameter addResourceMemberRequestBody: (body) User to add as owner 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func postTasksIDOwners(taskID: String, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: ResourceOwner?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        postTasksIDOwnersWithRequestBuilder(taskID: taskID, addResourceMemberRequestBody: addResourceMemberRequestBody, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     Add an owner to a task
     
     - parameter taskID: (path) The task ID. 
     - parameter addResourceMemberRequestBody: (body) User to add as owner 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func postTasksIDOwners(taskID: String, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan: String? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> ResourceOwner? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<ResourceOwner?, Error>) -> Void in
            postTasksIDOwnersWithRequestBuilder(taskID: taskID, addResourceMemberRequestBody: addResourceMemberRequestBody, zapTraceSpan: zapTraceSpan).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     Add an owner to a task
     - POST /tasks/{taskID}/owners
     - parameter taskID: (path) The task ID. 
     - parameter addResourceMemberRequestBody: (body) User to add as owner 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - returns: RequestBuilder<ResourceOwner> 
     */
    internal func postTasksIDOwnersWithRequestBuilder(taskID: String, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan: String? = nil) -> RequestBuilder<ResourceOwner> {
        var path = "/tasks/{taskID}/owners"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: addResourceMemberRequestBody)

        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<ResourceOwner> = influxDB2API.requestBuilderFactory.getRequestDecodableBuilder(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     Manually start a task run, overriding the current schedule
     
     - parameter taskID: (path)  
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter runManually: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func postTasksIDRuns(taskID: String, zapTraceSpan: String? = nil, runManually: RunManually? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: Run?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        postTasksIDRunsWithRequestBuilder(taskID: taskID, zapTraceSpan: zapTraceSpan, runManually: runManually).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     Manually start a task run, overriding the current schedule
     
     - parameter taskID: (path)  
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter runManually: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func postTasksIDRuns(taskID: String, zapTraceSpan: String? = nil, runManually: RunManually? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> Run? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Run?, Error>) -> Void in
            postTasksIDRunsWithRequestBuilder(taskID: taskID, zapTraceSpan: zapTraceSpan, runManually: runManually).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     Manually start a task run, overriding the current schedule
     - POST /tasks/{taskID}/runs
     - parameter taskID: (path)  
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter runManually: (body)  (optional)
     - returns: RequestBuilder<Run> 
     */
    internal func postTasksIDRunsWithRequestBuilder(taskID: String, zapTraceSpan: String? = nil, runManually: RunManually? = nil) -> RequestBuilder<Run> {
        var path = "/tasks/{taskID}/runs"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: runManually)

        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Run> = influxDB2API.requestBuilderFactory.getRequestDecodableBuilder(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

    /**
     Retry a task run
     
     - parameter taskID: (path) The task ID. 
     - parameter runID: (path) The run ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter body: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    public func postTasksIDRunsIDRetry(taskID: String, runID: String, zapTraceSpan: String? = nil, body: Any? = nil, apiResponseQueue: DispatchQueue? = nil, completion: @escaping (_ data: Run?,_ error: InfluxDBClient.InfluxDBError?) -> Void) {
        postTasksIDRunsIDRetryWithRequestBuilder(taskID: taskID, runID: runID, zapTraceSpan: zapTraceSpan, body: body).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    #if swift(>=5.5)
    /**
     Retry a task run
     
     - parameter taskID: (path) The task ID. 
     - parameter runID: (path) The run ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter body: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func postTasksIDRunsIDRetry(taskID: String, runID: String, zapTraceSpan: String? = nil, body: Any? = nil, apiResponseQueue: DispatchQueue? = nil) async throws -> Run? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Run?, Error>) -> Void in
            postTasksIDRunsIDRetryWithRequestBuilder(taskID: taskID, runID: runID, zapTraceSpan: zapTraceSpan, body: body).execute(apiResponseQueue ?? self.influxDB2API.apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    #endif

    /**
     Retry a task run
     - POST /tasks/{taskID}/runs/{runID}/retry
     - parameter taskID: (path) The task ID. 
     - parameter runID: (path) The run ID. 
     - parameter zapTraceSpan: (header) OpenTracing span context (optional)
     - parameter body: (body)  (optional)
     - returns: RequestBuilder<Run> 
     */
    internal func postTasksIDRunsIDRetryWithRequestBuilder(taskID: String, runID: String, zapTraceSpan: String? = nil, body: Any? = nil) -> RequestBuilder<Run> {
        var path = "/tasks/{taskID}/runs/{runID}/retry"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
        let runIDPreEscape = "\(APIHelper.mapValueToPathItem(runID))"
        let runIDPostEscape = runIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{runID}", with: runIDPostEscape, options: .literal, range: nil)
        let URLString = influxDB2API.basePath + "/api/v2" + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: body)

        let url = URLComponents(string: URLString)
        let nillableHeaders: [String: Any?] = [
            "Zap-Trace-Span": zapTraceSpan?.encodeToJSON()
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Run> = influxDB2API.requestBuilderFactory.getRequestDecodableBuilder(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true, headers: headerParameters, influxDB2API: influxDB2API)

        return requestBuilder
    }

}
}
